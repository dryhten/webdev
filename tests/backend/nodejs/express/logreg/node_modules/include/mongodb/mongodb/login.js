/*
 * login system based on the one I wrote in PHP for notes
 *
 * version 3 - using MongoDB
 *
 * to have only one "login.js" for both MySQL and MongoDB syntax stuff
 * (like querying the db) should be moved out of this file
 *
 * TODO check_errors and some other functions should be move to only one
 * file; right now they are the same in v1, v2 and mongodb
 */

/* events */
const EventEmitter = require("events");

/* require won't include twice the same module */
const connect = require("./connect.js");
const password = require("../../password.js");

function attempt_login(login_data, ee, args){
    /*
     * function that will attempt to log in a user from a local db
     * (specified in connect.js) using login credentials from login_data
     * when the function is done, an event "login" will be emitted for ee
     *
     * the callback will be called like this: (ret, args)
     * where ret is an object with success/failure and some messages
     * and args are arguments passed to this function
     *
     * login_data: {
     *   "username": ...,
     *   "password": ...
     * }
     *
     * ee: event emitter that listens for "login"
     * callback prototype: (ret, args)
     *
     * args: optional args that will be passed to ee.on("login")
     *
     * ret: {
     *   "success": ..., (true/false)
     *   "messages": [..., ...] (optional array of messages)
     *   "session": { (optional, in case of success)
     *     "uid": ..., (number, user id)
     *     "username": ..., (string)
     *     "email": ..., (string)
     *     "password": ..., (string)
     *   }
     * }
     */

    /*
     * check input - no need to continue if this is bad
     * also, this function is not that time consuming so it's prob
     * better to run it now and not later, in the event loop
     * */
    let ret = check_errors(login_data);
    if (ret["success"] === false){
	ee.emit("login", ret, args);
	return;
    }

    let connection;
    const login_emitter = new EventEmitter();

    /*
     * connect to db
     * start the chain of async functions
     * */
    connect.connect_to_db(login_emitter, "connection");

    /* when connection is done */
    login_emitter.on("connection", function(ret){
	if (ret["success"] === false) {
	    ee.emit("login", ret, args);
	    return;
	}
	connection = ret["connection"];
	/* check credentials and log in */
	login(login_data, connection, login_emitter, "login");
    });

    /* when login is done */
    login_emitter.on("login", function(ret){
	/*
	 * since we need to close the connection anyway this will do
	 * however, a better idea would be to wrap connection.close()
	 * since it's also an async function, and emit "login"
	 * only when it's done
	 * */
	connection.close();
	ee.emit("login", ret, args);
    });
}

function check_errors(login_data){
    /*
     * check if username/password is empty
     * might be a good idea to check if !str works all the time
     * for empty strings with all the javascript type coercion
     * */
    let success = true;
    let messages = [];
    if (!login_data["username"]){
	messages.push("Please enter a username");
	success = false;
    }
    if (!login_data["password"]){
	messages.push("Please enter a password");
	success = false;
    }
    return {"success": success, "messages": messages};
}

function login(login_data, connection, ee, event){
    /*
     * login_data: {
     *   "username": ...,
     *   "password": ...
     * }
     *
     * connection: Db object (from MongoDB node.js driver)
     *
     * ee: event emitter that listens for event with params (ret, args)
     *
     * ret: {
     *   "success": ..., (true/false)
     *   "messages": [..., ...] (optional array of messages)
     *   "session": { (optional, in case of success)
     *     "uid": ..., (number, user id)
     *     "username": ..., (string)
     *     "email": ..., (string)
     *     "password": ..., (string)
     *   }
     * }
     */

    /*
     * apparently there is no need for sanitizing input here
     * login_data["username"] is interpreted as a string (not executed)
     * and mongodb will just compare that string with other values in
     * username field
     *
     * also, login_data is sure a string in my case, I convert everything
     * I get from POST (could be a custom POST request via curl or something)
     * to string before I parse it and store the params (as strings)
     *
     * one potential attack that can happen is if I do password and username
     * matching in one request, and if I get a result (len > 0) then I
     * auth the user
     *
     * if a custom POST is made to the URL with "username_login" field
     * set to {username: {"$gt": ""}, password: {"$gt": ""}} this will
     * retrive all users and match all passwords as well, so the user
     * will be logged in as the first user (prob admin)
     *
     * since I convert everything I get via POST to string, this won't
     * work in my case; also, I only retrive after users first and
     * check password later, so it won't work anyway
     * */
    let filter = {username: login_data["username"]};
    connection.collection("Users").find(filter).toArray(function(err, result){
	if (err){
	    let ret = {
		success: false,
		messages: ["Error retrieving user: " + err.message],
	    }
	    ee.emit(event, ret);
	    return;
	}
	if (result.length < 1){
	    let ret = {
		success: false,
		messages: ["Bad login details"],
	    }
	    ee.emit(event, ret);
	    return;
	}
	/*
	 * same assumptions as login_base.php - if we have multiple rows
	 * as result, just look at the first one; this might result in errors
	 * if we allow multiple users with the same name - but this is not true
	 * the username is the unique identifier for a user so no duplicates
	 *
	 * also, this function and the signup one assume that the documents
	 * have "username", "email" and "password" fields - with MongoDB
	 * this is not always the case (some errors might cause different
	 * fields in the DB)
	 *
	 * TODO - maybe make sure we have them before anything
	 * something like - while we fields don't match, move to the next one
	 * if we reach end - error, else continue with the code below
	 */
	let user_data = {
	    username: login_data["username"],
	    email: result[0]["email"],
	    password: login_data["password"],
	};
	if (result[0]["password"] != password.hash_password(user_data)){
	    let ret = {
		success: false,
		messages: ["Bad login details"],
	    }
	    ee.emit(event, ret);
	    return;
	}
	// save info in session variables
	let ret = {
	    "success": true,
	    "messages": ["success"],
	    "session": {
		"uid": result[0]["_id"],
		"username": result[0]["username"],
		"email": result[0]["email"],
		"password": result[0]["password"],
	    },
	};
	ee.emit(event, ret);
    });
}

/* exports */
module.exports.attempt_login = attempt_login;
